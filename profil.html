<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grimoire ¬∑ Profil</title>

<!-- DOIT √äTRE AVANT les <link rel="stylesheet"> -->
<script>
  (function(){
    try{
      var saved = localStorage.getItem('grimoire.theme');
      if (saved === 'halloween') {
        document.documentElement.classList.add('halloween');
      }
    }catch(e){}
  })();
</script>

  
  <!-- Harmonisation -->
  <link rel="stylesheet" href="/rarities.css">
  <link rel="stylesheet" href="/mobile.css">
  <link rel="stylesheet" href="/halloween.css">

  <link rel="icon" type="image/png" href="https://i.goopics.net/07jxhq.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://i.goopics.net/aksxey.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://i.goopics.net/clovpw.png">
  <link rel="apple-touch-icon" href="https://i.goopics.net/cb7vh3.png">

  <style>
    :root{
      --bg:#0b0f1a; --panel:#10172a; --panel-2:#0c1222; --text:#e8ecf3; --muted:#9aa6be;
      --accent:#7c5cff; --accent-2:#b86bff; --copper:#d6a17a; --success:#34d399; --warning:#f59e0b;
      --radius:16px; --radius-lg:24px; --shadow:0 20px 60px rgba(0,0,0,.45); --shadow-sm:0 8px 24px rgba(0,0,0,.25);
    }
    *{box-sizing:border-box; scrollbar-width:thin; scrollbar-color: rgba(124,92,255,.45) rgba(255,255,255,.04)}
    *::-webkit-scrollbar{ height:10px; width:10px }
    *::-webkit-scrollbar-track{ background: rgba(255,255,255,.04) }
    *::-webkit-scrollbar-thumb{ background: linear-gradient(180deg, rgba(124,92,255,.7), rgba(184,107,255,.6)); border-radius:999px; border:2px solid rgba(11,15,26,.6) }

    body{
      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; color:var(--text);
      background:
        radial-gradient(1200px 600px at 10% -10%, rgba(124,92,255,.18), transparent 60%),
        radial-gradient(900px 500px at 110% 10%, rgba(184,107,255,.16), transparent 60%),
        radial-gradient(1000px 800px at 50% 120%, rgba(214,161,122,.10), transparent 60%),
        linear-gradient(180deg,#0b0f1a 0%,#0b0f1a 100%);
      min-height:100svh;
    }

    header{position:sticky; top:0; z-index:10; backdrop-filter:blur(10px);
      background:linear-gradient(180deg,rgba(11,15,26,.85),rgba(11,15,26,.55));
      border-bottom:1px solid rgba(255,255,255,.06)
    }
    .container{max-width:1100px;margin:0 auto;padding:22px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    nav a{color:var(--text);text-decoration:none;border:1px solid rgba(255,255,255,.12);padding:8px 12px;border-radius:12px}
    nav a[aria-current="page"]{ background:rgba(255,255,255,.06) }
    nav a:hover{ background: rgba(255,255,255,.08) }

    .brand{display:flex;align-items:center;gap:14px}
    .logo{width:44px;height:44px;border-radius:14px;background:conic-gradient(from 0deg,var(--accent),var(--accent-2),var(--copper),var(--accent));box-shadow:var(--shadow-sm)}
    .title{font-size:22px;font-weight:900}
    .subtitle{font-size:12px;color:var(--muted)}

    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:20px}
    @media (max-width: 960px){ .grid{ grid-template-columns: repeat(6, 1fr) } }
    @media (max-width: 640px){ .grid{ grid-template-columns: repeat(4, 1fr) } }

    .panel{
      background:linear-gradient(180deg,var(--panel),var(--panel-2));
      border:1px solid rgba(255,255,255,.06); border-radius:var(--radius-lg);
      box-shadow:var(--shadow); position:relative; overflow:clip
    }
    .panel .hd{display:flex;align-items:center;justify-content:space-between;padding:18px 20px;border-bottom:1px solid rgba(255,255,255,.06)}
    .panel .hd h3{margin:0; font-size:16px; letter-spacing:.2px}
    .panel .bd{padding:18px 20px}
    .panel::before{content:""; position:absolute; inset:0; border-radius:inherit; padding:1px;
      background: linear-gradient(140deg, rgba(124,92,255,.35), rgba(184,107,255,.2), rgba(214,161,122,.28));
      -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      -webkit-mask-composite: xor; mask-composite: exclude; pointer-events:none; }

    .statline{display:flex; align-items:center; gap:14px; flex-wrap:wrap}
    .avatar{ width:56px; height:56px; border-radius:14px; background:#0e1423; border:1px solid rgba(255,255,255,.10); overflow:hidden; display:grid; place-items:center; font-weight:900 }
    .user-meta .name{ font-weight:900; letter-spacing:.2px; }
    .user-meta .k{ font-size:12px; color: var(--muted) }

    .xpwrap{ display:flex; align-items:center; gap:10px; flex-wrap:wrap }
    .xpbar{ height:12px; border-radius:999px; background:#0e1423; border:1px solid rgba(255,255,255,.08); overflow:hidden; flex:1; min-width:180px }
    .xpbar .fill{ height:100%; width:0; background:linear-gradient(90deg,var(--accent),var(--accent-2)); box-shadow: inset 0 0 18px rgba(124,92,255,.35); transition: width .25s ease }
    .pill{font-size:12px;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12)}

    /* Badges */
    .badges{ display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:12px }
    .badge-card{
      position:relative; border-radius:14px; padding:12px;
      background: linear-gradient(180deg,#0f1324,#0a0f1e);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 6px 20px rgba(0,0,0,.35);
      transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease;
      cursor: default;
    }
    .badge-card:hover{ transform: translateY(-2px); box-shadow: 0 12px 30px rgba(124,92,255,.18) }
    .badge-ico{ font-size:28px; line-height:1; }
    .badge-name{ font-weight:800; margin-top:6px }
    .badge-desc{ font-size:12px; color: var(--muted); margin-top:4px; min-height:30px }
    .badge-state{ position:absolute; top:10px; right:10px; font-size:12px; }
    .badge-card.locked{ filter: grayscale(.3) opacity(.8) }
    .badge-card.locked::after{
      content:""; position:absolute; inset:0; border-radius:inherit; background: rgba(0,0,0,.35);
    }
    .badge-card .date{ font-size:11px; color: var(--muted); margin-top:6px }

    .toast{
      position: fixed; left: 50%; bottom: 22px; transform: translateX(-50%);
      background: rgba(18,24,41,.92); color: var(--text); border:1px solid rgba(255,255,255,.12);
      padding:10px 14px; border-radius:12px; box-shadow: var(--shadow-sm); z-index: 50;
      opacity:0; transition: opacity .2s ease, transform .2s ease
    }
    .toast.show{ opacity:1; transform: translateX(-50%) translateY(-4px) }

    @media (max-width: 640px){
      .container{ padding:12px; }
      .title{ font-size:18px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="container row" style="justify-content:space-between">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <div class="title">Grimoire</div>
          <div class="subtitle">Profil & Badges</div>
        </div>
      </div>
      <nav class="row" style="gap:10px">
        <a href="/index.html">‚Üê Retour au jeu</a>
        <a href="/collection.html">Collection</a>
        <a href="/profil.html" aria-current="page">Profil</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <!-- Profil joueur -->
    <section class="panel" style="grid-column:span 12; margin-bottom:16px">
      <div class="hd">
        <h3>Infos joueur</h3>
        <span id="sync" class="pill">Chargement‚Ä¶</span>
      </div>
      <div class="bd">
        <div class="statline">
          <div id="avatar" class="avatar" aria-hidden="true">üë§</div>
          <div class="user-meta">
            <div class="name" id="username">‚Äî</div>
            <div class="k">Niveau <strong id="level">0</strong> ¬∑ <span id="xpLabel">0 XP</span></div>
          </div>
        </div>
        <div class="xpwrap" style="margin-top:12px">
          <div class="xpbar" aria-label="Progression vers le prochain niveau">
            <div class="fill" id="xpFill" style="width:0%"></div>
          </div>
          <span class="pill" id="xpPct">0%</span>
        </div>
      </div>
    </section>

    <!-- Badges -->
    <section class="panel" style="grid-column:span 12">
      <div class="hd">
        <h3>Badges</h3>
        <span class="subtitle">D√©bloque-les en jouant, collectionnant et en te connectant r√©guli√®rement.</span>
      </div>
      <div class="bd">
        <div id="badges" class="badges"></div>
      </div>
    </section>
  </main>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <!-- === LOGIQUE ALIGNEE AVEC collection.html === -->
 <script type="module">
// Firebase (modules v10, comme collection.html)
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
import { getAuth, onAuthStateChanged, OAuthProvider, setPersistence, browserLocalPersistence } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
import { getFirestore, doc, getDoc, setDoc, updateDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

   function xpForLevel(level){ return 50 * Math.max(1, level); }

   
const LS_VERSION_KEY = 'grimoire.alpha.version';
const CURRENT_LS_VERSION = 3; // incr√©mente si tu modifies l‚Äôarchitecture

const last = Number(localStorage.getItem(LS_VERSION_KEY)||0);
if (last !== CURRENT_LS_VERSION){
  // localStorage.removeItem('grimoire.alpha.collection.v2_5');
  // localStorage.removeItem('grimoire.alpha.stats.v2_5');
  // localStorage.removeItem('grimoire.alpha.profile.v2_5');
  localStorage.setItem(LS_VERSION_KEY, String(CURRENT_LS_VERSION));
}

// ---- Config identique
const firebaseConfig = {
  apiKey: 'AIzaSyCKZK4I3li_7wkmd_qiiM44BoqRTZoloeI',
  authDomain: 'legends-collection.firebaseapp.com',
  projectId: 'legends-collection',
  storageBucket: 'legends-collection.firebasestorage.app',
  messagingSenderId: '133783086150',
  appId: '1:133783086150:web:762f209f7f778ef83a1647'
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db   = getFirestore(app);
try { await setPersistence(auth, browserLocalPersistence); } catch {}

const twitchProvider = new OAuthProvider('oidc.twitch');
try { twitchProvider.addScope('openid'); twitchProvider.addScope('user:read:email'); } catch {}

// ---- Raret√©s + mapping (m√™me normalisation que collection.html)
const RARITY = { COMMON:'commune', UNCOMMON:'peu commune', RARE:'rare', LEGENDARY:'l√©gendaire', EXOTIC:'exotique', INCANDESCENT:'incandescent' };
function mapRarity(r){
  const x=(r||'').toLowerCase();
  if(x==='common'||x==='commune') return RARITY.COMMON;
  if(x==='uncommon'||x==='peu commune') return RARITY.UNCOMMON;
  if(x==='rare') return RARITY.RARE;
  if(x==='legendary'||x==='legendaire'||x==='l√©gendaire') return RARITY.LEGENDARY;
  if(x==='exotic'||x==='exotique') return RARITY.EXOTIC;
  if(x==='incandescent'||x==='incandesceant'||x==='super-exotic') return RARITY.INCANDESCENT; // üëç
  return RARITY.COMMON;
}

   // üëâ ID de la carte collector Anniversaire 2025
const ANNIV2025_ID = '32ans';

// ---- Chargement dynamique des sets (identique aux chemins de collection.html)
const SET_FILES = [
  '/data/sets/nouvelle-lumiere.json',
  '/data/sets/twitch.json',
  '/data/sets/speciales.json',
  '/data/sets/super-stream.json',
];

async function loadCardSets(){
  const out = [];
  for (const url of SET_FILES){
    try{
      const res = await fetch(url, { cache:'no-store' });
      if(!res.ok) throw new Error('HTTP '+res.status);
      const data = await res.json();
      const setName =
  data?.set || data?.name ||
  (url.includes('nouvelle-lumiere') ? 'Nouvelle Lumi√®re' :
   url.includes('twitch') ? 'Twitch' :
   url.includes('super-stream') ? 'Super Stream' :
   'Set inconnu');


      if(!Array.isArray(data?.cards)) continue;
      out.push(...data.cards.map(c=>({
        id: c.id,
        name: c.name,
        set: c.set || setName,
        rarity: mapRarity(c.rarity),
        image: c.image || ''
      })));
    }catch(e){
      console.warn('[profil] loadCardSets fail', url, e);
    }
  }
  return out;
}

// ---- LocalStorage (m√™mes cl√©s)
const LS_KEY='grimoire.alpha.collection.v2_6';
const LS_STATS='grimoire.alpha.stats.v2_6';
const LS_PROFILE='grimoire.alpha.profile.v2_6';
function loadLS(k,def){ try{ return JSON.parse(localStorage.getItem(k))||def; }catch{ return def; } }
function saveLS(k,v){ localStorage.setItem(k, JSON.stringify(v)); }

// Seuls ces 2 sets comptent pour le badge ARCHIVISTE
const LAUNCH_SETS = new Set(['Nouvelle Lumi√®re','Twitch']);

// Set cibl√© pour le badge "Super Stream"
const SUPER_STREAM_SET = 'Super Stream';

   
// ---- Compute centralis√©
function computeProgress({ collection, cardPools }){
  // ----- Stats globales (inchang√©es)
  const allIds = new Set(cardPools.map(c=>c.id));
  const totalUnique = allIds.size;

  const ownedIds = Object.keys(collection).filter(id => allIds.has(id));
  const uniques = ownedIds.length;

  const completionPct = totalUnique ? Math.round(100 * uniques / totalUnique) : 0;

  const byRarity = {
    [RARITY.COMMON]:0, [RARITY.UNCOMMON]:0, [RARITY.RARE]:0, [RARITY.LEGENDARY]:0, [RARITY.EXOTIC]:0
  };
  for(const id of ownedIds){
    const qty = collection[id] || 0;
    const card = cardPools.find(c => c.id === id);
    if(card) byRarity[card.rarity] += qty;
  }

  const legendaryOwned = ownedIds.some(id => {
    const card = cardPools.find(c=>c.id===id);
    return card && card.rarity === RARITY.LEGENDARY && (collection[id]||0) > 0;
  });
  const exoticOwned = ownedIds.some(id => {
    const card = cardPools.find(c=>c.id===id);
    return card && card.rarity === RARITY.EXOTIC && (collection[id]||0) > 0;  });

  const exoticUnique = ownedIds.reduce((n, id) => {
  const card = cardPools.find(c => c.id === id);
  return n + (card && card.rarity === RARITY.EXOTIC ? 1 : 0);
}, 0);

  // ----- Stats "sets de lancement" (Nouvelle Lumi√®re + Twitch) ‚Üí pour ARCHIVISTE
  const launchIds = new Set(
    cardPools
      .filter(c => LAUNCH_SETS.has(c.set))
      .map(c => c.id)
  );
  const launchOwnedUnique = Array.from(launchIds).filter(id => (collection[id] || 0) > 0).length;
  const launchCompletionPct = launchIds.size ? Math.round(100 * launchOwnedUnique / launchIds.size) : 0;
  const launchCompleted = launchIds.size > 0 && launchOwnedUnique === launchIds.size;

  // ----- Stats "Super Stream" ‚Üí pour le nouveau badge
  const ssIds = new Set(
    cardPools
      .filter(c => c.set === SUPER_STREAM_SET)
      .map(c => c.id)
  );
  const ssOwnedUnique = Array.from(ssIds).filter(id => (collection[id] || 0) > 0).length;
  const superStreamCompletionPct = ssIds.size ? Math.round(100 * ssOwnedUnique / ssIds.size) : 0;
  const superStreamCompleted = ssIds.size > 0 && ssOwnedUnique === ssIds.size;

  return { 
  uniques, totalUnique, completionPct, 
  byRarity, legendaryOwned, exoticOwned,
  launchCompletionPct, launchCompleted,
  superStreamCompletionPct, superStreamCompleted,
  exoticUnique // üÜï
};
}

 
// ---- Version de sch√©ma badges + helpers de resync
const BADGE_SCHEMA_VERSION = 6;

function computeExpectedBadges(sharedStats){
  const expected = {};
  for(const b of BADGES){
    if (b.test(sharedStats)) {
      expected[b.id] = { acquiredAt: serverTimestamp() };
    }
  }
  return expected;
}
function diffBadges(currentBadges={}, expectedBadges={}){
  const toAdd = [];
  const toRemove = [];
  for(const id of Object.keys(currentBadges)){
    if(!(id in expectedBadges)) toRemove.push(id);
  }
  for(const id of Object.keys(expectedBadges)){
    if(!(id in currentBadges)) toAdd.push(id);
  }
  return { toAdd, toRemove };
}

// ---- Badges
const BADGES = [
  { id:'explorateur',    name:'Explorateur',         ico:'üß≠',  desc:'Avoir 10 cartes diff√©rentes',   test:s=> s.uniques >= 10 },
  { id:'collectionneur', name:'Collectionneur',      ico:'üìö',  desc:'50% de la collection',         test:s=> s.completionPct >= 50 },
  { id:'archiviste',  name:'Archiviste',  ico:'üèõÔ∏è',  desc:'Compl√©ter les sets de lancement : Nouvelle Lumi√®re + Twitch',  test: s => !!s.launchCompleted },
  { id:'superheros', name:'Super H√©ros', ico:'ü¶∏‚Äã',  desc:'Compl√©ter la collection Super Stream',  test: s => !!s.superStreamCompleted },
  { id:'anniv2025',  name:'Anniversaire 2025',  ico:'üéÇ',  desc:'Pr√©sent(e) au stream Anniversaire 2025',  test: s => !!s.hasAnniv2025 },

  { id:'curieux',        name:'Curieux',             ico:'üì¶',  desc:'Ouvrir un premier pack',       test:s=> (s.packsOpened||0) >= 1 },
  { id:'addict',         name:'Addict',              ico:'üì¶üì¶', desc:'Ouvrir 50 packs',              test:s=> (s.packsOpened||0) >= 50 },
  { id:'accro',          name:'Accro',               ico:'üì¶üì¶üì¶',desc:'Ouvrir 100 packs',             test:s=> (s.packsOpened||0) >= 100 },
  { id:'inarretable',    name:'Inarr√™table',         ico:'üåÄ',  desc:'Ouvrir 200 packs',             test:s=> (s.packsOpened||0) >= 200 },
  { id:'paaaaacks',    name:'Des paaaaacks',         ico:'üåÄüåÄ',  desc:'Ouvrir 500 packs',             test:s=> (s.packsOpened||0) >= 500 },

  { id:'chanceux',       name:'Chanceux',            ico:'üåü',  desc:'Trouver 1 l√©gendaire',         test:s=> !!s.legendaryOwned },
  { id:'benisdesneuf',   name:'B√©nis des Neuf',      ico:'‚ú®',  desc:'Trouver 1 exotique',           test:s=> !!s.exoticOwned },
  { id:'chasseur',       name:'Chasseur de tr√©sors', ico:'üíé',  desc:'10 l√©gendaires/exotiques',     test:s=> ((s.byRarity['l√©gendaire']||0)+(s.byRarity['exotique']||0)) >= 10 },
  { id:'brillance', name:'La brillance', ico:'üí†',  desc:'Trouver 10 exotiques',  test: s => (s.exoticUnique || 0) >= 10 },
  { id:'toujoursplus', name:'Toujours plus', ico:'‚≠ê', desc:'Trouver 20 exotiques', test: s => (s.exoticUnique || 0) >= 20 },


  { id:'apprenti',       name:'Apprenti',         ico:'üî®',  desc:'Atteindre le niveau 5',            test:s=> (s.level||0) >= 5 },
  { id:'gardienconfirme',name:'En formation', ico:'‚öíÔ∏è',  desc:'Atteindre le niveau 20',   test:s=> (s.level||0) >= 20 },
  { id:'expert',name:'Expert-e', ico:'‚öîÔ∏è‚Äã',  desc:'Atteindre le niveau 50',   test:s=> (s.level||0) >= 50 },

  { id:'halloween2025',  name:"Esprit d'Halloween 2025",  ico:'üéÉ',  desc:"Avoir activ√© le th√®me Halloween 2025",  test: s => !!(s.hadHalloweenBadge || s.halloweenActive)
},

  
];

// ---- UI helpers
const $ = (sel)=> document.querySelector(sel);
const toastEl = $('#toast');
function toast(msg, ms=1800){
  toastEl.textContent = msg;
  toastEl.classList.add('show');
  setTimeout(()=> toastEl.classList.remove('show'), ms);
}
function renderBadges(container, defs, ownedMap){
  container.innerHTML = '';
  defs.forEach(b=>{
    const unlocked = !!ownedMap[b.id];
    const date = ownedMap[b.id]?.acquiredAt ? new Date(ownedMap[b.id].acquiredAt.seconds*1000) : null;

    const card = document.createElement('div');
    card.className = 'badge-card'+(unlocked?'':' locked');
    card.innerHTML = `
      <div class="badge-state">${unlocked? 'D√©bloqu√©' : 'Verrouill√©'}</div>
      <div class="badge-ico" aria-hidden="true">${b.ico}</div>
      <div class="badge-name">${b.name}</div>
      <div class="badge-desc">${b.desc}</div>
      ${unlocked && date ? `<div class="date">D√©bloqu√© le ${date.toLocaleDateString()}</div>` : ''}
    `;
    container.appendChild(card);
  });
}

// ---- Refs DOM
const usernameEl = $('#username');
const levelEl    = $('#level');
const xpLabelEl  = $('#xpLabel');
const xpFillEl   = $('#xpFill');
const xpPctEl    = $('#xpPct');
const avatarEl   = $('#avatar');
const syncBadge  = $('#sync');
const badgesWrap = $('#badges');

// ---- Etat
let cardPools = [];
let collection = loadLS(LS_KEY, {});
let stats = loadLS(LS_STATS, { packsOpened: 0 });
let profileLS = loadLS(LS_PROFILE, { level:1, xp:0 });

// ---- Orchestration
// 1) Charger le catalogue
cardPools = await loadCardSets();

// 2) Auth & synchro Cloud ‚Üí Local, puis calcul des stats communes
onAuthStateChanged(auth, async (user)=>{
  if(!user){
    syncBadge.textContent = 'Hors ligne';
    usernameEl.textContent = 'Invit√©';
    levelEl.textContent = String(profileLS.level||0);
    const need = xpForLevel(profileLS.level || 1);
xpLabelEl.textContent = `XP ${profileLS.xp||0} / ${need}`;
const p = Math.max(0, Math.min(100, Math.round((profileLS.xp / need) * 100)));
xpFillEl.style.width = p + '%';
xpPctEl.textContent = p + '%';


    const progress = computeProgress({ collection, cardPools });
    draw({ ...progress, packsOpened: stats.packsOpened, level: profileLS.level }, {}); // rendu (tout verrouill√© si pas de badges)
    return;
  }

  syncBadge.textContent = 'Sync‚Ä¶';
  avatarEl.textContent = 'üë§';

  const ref = doc(db,'players',user.uid);
  const snap = await getDoc(ref);
  const data = snap.exists()? snap.data() : {};

  // R√©cup collection (divers sch√©mas)
  function collectOwned(d){
    const ids = {};
    if (d.collection && typeof d.collection === 'object'){
      for (const [id, qty] of Object.entries(d.collection)) ids[id]=Number(qty||0);
    }
    if (d.collections && typeof d.collections === 'object'){
      for (const setObj of Object.values(d.collections)){
        if (setObj && typeof setObj === 'object'){
          for (const [id, qty] of Object.entries(setObj)) ids[id]=(ids[id]||0)+Number(qty||0);
        }
      }
    }
    if (Array.isArray(d.cardsOwned)){
      for (const entry of d.cardsOwned){
        if (typeof entry === 'string') ids[entry]=(ids[entry]||0)+1;
        else if (entry && entry.id) ids[entry.id]=(ids[entry.id]||0)+Number(entry.qty||1);
      }
    }
    // 4) Collection sp√©ciale (collectors / √©v√©nements)
    if (d.specialCollection && typeof d.specialCollection === 'object'){
      for (const [id, qty] of Object.entries(d.specialCollection)){
        ids[id] = (ids[id] || 0) + Number(qty || 0);
      }
    }
    return ids;
  }

  collection = collectOwned(data);
  stats.packsOpened = data.packsOpened ?? data.stats?.packsOpened ?? stats.packsOpened ?? 0;
  profileLS.level = data.level ?? profileLS.level ?? 1;
  profileLS.xp    = data.xp    ?? profileLS.xp    ?? 0;

  saveLS(LS_KEY, collection); saveLS(LS_STATS, stats); saveLS(LS_PROFILE, profileLS);

  // UI Infos joueur
  usernameEl.textContent = data.pseudo || user.displayName || user.email || 'Joueur';
  levelEl.textContent = String(profileLS.level||0);
  const need = xpForLevel(profileLS.level || 1);
xpLabelEl.textContent = `XP ${profileLS.xp||0} / ${need}`;
const p = Math.max(0, Math.min(100, Math.round((profileLS.xp / need) * 100)));
xpFillEl.style.width = p + '%';
xpPctEl.textContent = p + '%';


  const progress = computeProgress({ collection, cardPools });

  // Fusion des stats utiles pour badges
  const hasAnniv2025 =
  (data.specialCollection?.[ANNIV2025_ID] || 0) > 0 ||
  (collection[ANNIV2025_ID] || 0) > 0;

// juste avant sharedStats
const halloweenActive   = (localStorage.getItem('grimoire.theme') === 'halloween');
const hadHalloweenBadge = !!((data.badges || {}).halloween2025);

// sharedStats existant ‚Üí ajoute les deux flags :
const sharedStats = {
  ...progress,
  packsOpened: stats.packsOpened,
  level: profileLS.level,
  hasAnniv2025,
  halloweenActive,     // üÜï
  hadHalloweenBadge    // üÜï
};

  // Badges existants
  let ownedBadges = data.badges || {};

  // === Resynchronisation automatique ===
  const expected = computeExpectedBadges(sharedStats);
  const { toAdd, toRemove } = diffBadges(ownedBadges, expected);
  const needsVersionBump = (data.badgeSchemaVersion || 0) !== BADGE_SCHEMA_VERSION;

  if (toAdd.length || toRemove.length || needsVersionBump) {
    const now = serverTimestamp();
    const finalBadges = { ...ownedBadges };

    for(const id of toRemove){ delete finalBadges[id]; }
    for(const id of toAdd){ finalBadges[id] = { acquiredAt: now }; }

    try{
      if (snap.exists()) {
        await updateDoc(ref, { badges: finalBadges, badgeSchemaVersion: BADGE_SCHEMA_VERSION, updatedAt: now });
      } else {
        await setDoc(ref, { badges: finalBadges, badgeSchemaVersion: BADGE_SCHEMA_VERSION, createdAt: now, updatedAt: now }, { merge: true });
      }

      if (toAdd.length || toRemove.length) {
        const plus = toAdd.length ? `+${toAdd.length}` : '';
        const moins = toRemove.length ? `-${toRemove.length}` : '';
        toast(`Badges resynchronis√©s ${[plus,moins].filter(Boolean).join(' / ')}`);
      }

      const snap2 = await getDoc(ref);
      ownedBadges = (snap2.exists()? snap2.data().badges : finalBadges) || finalBadges;
    }catch(e){
      console.error(e);
      toast('Erreur lors de la resynchronisation des badges');
    }
  }

  draw(sharedStats, ownedBadges);
  syncBadge.textContent = 'En ligne';
}); // <<< FIN onAuthStateChanged (manquait dans ta version)

// ---- Rendu
function draw(sharedStats, ownedBadges){
  renderBadges(badgesWrap, BADGES, ownedBadges || {});
  // console.log('[profil] stats', sharedStats, 'badges', ownedBadges);
}
</script>

<script>
  (function(){
    var saved = localStorage.getItem('grimoire.theme');
    var on = (saved === 'halloween');
    document.body.classList.toggle('halloween', on);
  })();
</script>

  
</body>
</html>
