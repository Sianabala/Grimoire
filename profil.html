<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grimoire ¬∑ Profil</title>

  <!-- Harmonisation -->
  <link rel="stylesheet" href="/rarities.css">
  <link rel="stylesheet" href="/mobile.css">
  <link rel="icon" type="image/png" href="https://i.goopics.net/07jxhq.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://i.goopics.net/aksxey.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://i.goopics.net/clovpw.png">
  <link rel="apple-touch-icon" href="https://i.goopics.net/cb7vh3.png">

  <style>
    :root{
      --bg:#0b0f1a; --panel:#10172a; --panel-2:#0c1222; --text:#e8ecf3; --muted:#9aa6be;
      --accent:#7c5cff; --accent-2:#b86bff; --copper:#d6a17a; --success:#34d399; --warning:#f59e0b;
      --radius:16px; --radius-lg:24px; --shadow:0 20px 60px rgba(0,0,0,.45); --shadow-sm:0 8px 24px rgba(0,0,0,.25);
    }
    *{box-sizing:border-box; scrollbar-width:thin; scrollbar-color: rgba(124,92,255,.45) rgba(255,255,255,.04)}
    *::-webkit-scrollbar{ height:10px; width:10px }
    *::-webkit-scrollbar-track{ background: rgba(255,255,255,.04) }
    *::-webkit-scrollbar-thumb{ background: linear-gradient(180deg, rgba(124,92,255,.7), rgba(184,107,255,.6)); border-radius:999px; border:2px solid rgba(11,15,26,.6) }

    body{
      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; color:var(--text);
      background:
        radial-gradient(1200px 600px at 10% -10%, rgba(124,92,255,.18), transparent 60%),
        radial-gradient(900px 500px at 110% 10%, rgba(184,107,255,.16), transparent 60%),
        radial-gradient(1000px 800px at 50% 120%, rgba(214,161,122,.10), transparent 60%),
        linear-gradient(180deg,#0b0f1a 0%,#0b0f1a 100%);
      min-height:100svh;
    }

    header{position:sticky; top:0; z-index:10; backdrop-filter:blur(10px);
      background:linear-gradient(180deg,rgba(11,15,26,.85),rgba(11,15,26,.55));
      border-bottom:1px solid rgba(255,255,255,.06)
    }
    .container{max-width:1100px;margin:0 auto;padding:22px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    nav a{color:var(--text);text-decoration:none;border:1px solid rgba(255,255,255,.12);padding:8px 12px;border-radius:12px}
    nav a[aria-current="page"]{ background:rgba(255,255,255,.06) }
    nav a:hover{ background: rgba(255,255,255,.08) }

    .brand{display:flex;align-items:center;gap:14px}
    .logo{width:44px;height:44px;border-radius:14px;background:conic-gradient(from 0deg,var(--accent),var(--accent-2),var(--copper),var(--accent));box-shadow:var(--shadow-sm)}
    .title{font-size:22px;font-weight:900}
    .subtitle{font-size:12px;color:var(--muted)}

    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:20px}
    @media (max-width: 960px){ .grid{ grid-template-columns: repeat(6, 1fr) } }
    @media (max-width: 640px){ .grid{ grid-template-columns: repeat(4, 1fr) } }

    .panel{
      background:linear-gradient(180deg,var(--panel),var(--panel-2));
      border:1px solid rgba(255,255,255,.06); border-radius:var(--radius-lg);
      box-shadow:var(--shadow); position:relative; overflow:clip
    }
    .panel .hd{display:flex;align-items:center;justify-content:space-between;padding:18px 20px;border-bottom:1px solid rgba(255,255,255,.06)}
    .panel .hd h3{margin:0; font-size:16px; letter-spacing:.2px}
    .panel .bd{padding:18px 20px}
    .panel::before{content:""; position:absolute; inset:0; border-radius:inherit; padding:1px;
      background: linear-gradient(140deg, rgba(124,92,255,.35), rgba(184,107,255,.2), rgba(214,161,122,.28));
      -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      -webkit-mask-composite: xor; mask-composite: exclude; pointer-events:none; }

    .statline{display:flex; align-items:center; gap:14px; flex-wrap:wrap}
    .avatar{ width:56px; height:56px; border-radius:14px; background:#0e1423; border:1px solid rgba(255,255,255,.10); overflow:hidden; display:grid; place-items:center; font-weight:900 }
    .user-meta .name{ font-weight:900; letter-spacing:.2px; }
    .user-meta .k{ font-size:12px; color: var(--muted) }

    .xpwrap{ display:flex; align-items:center; gap:10px; flex-wrap:wrap }
    .xpbar{ height:12px; border-radius:999px; background:#0e1423; border:1px solid rgba(255,255,255,.08); overflow:hidden; flex:1; min-width:180px }
    .xpbar .fill{ height:100%; width:0; background:linear-gradient(90deg,var(--accent),var(--accent-2)); box-shadow: inset 0 0 18px rgba(124,92,255,.35); transition: width .25s ease }
    .pill{font-size:12px;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12)}

    /* Badges */
    .badges{ display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:12px }
    .badge-card{
      position:relative; border-radius:14px; padding:12px;
      background: linear-gradient(180deg,#0f1324,#0a0f1e);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 6px 20px rgba(0,0,0,.35);
      transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease;
      cursor: default;
    }
    .badge-card:hover{ transform: translateY(-2px); box-shadow: 0 12px 30px rgba(124,92,255,.18) }
    .badge-ico{ font-size:28px; line-height:1; }
    .badge-name{ font-weight:800; margin-top:6px }
    .badge-desc{ font-size:12px; color: var(--muted); margin-top:4px; min-height:30px }
    .badge-state{ position:absolute; top:10px; right:10px; font-size:12px; }
    .badge-card.locked{ filter: grayscale(.3) opacity(.8) }
    .badge-card.locked::after{
      content:""; position:absolute; inset:0; border-radius:inherit; background: rgba(0,0,0,.35);
    }
    .badge-card .date{ font-size:11px; color: var(--muted); margin-top:6px }

    .toast{
      position: fixed; left: 50%; bottom: 22px; transform: translateX(-50%);
      background: rgba(18,24,41,.92); color: var(--text); border:1px solid rgba(255,255,255,.12);
      padding:10px 14px; border-radius:12px; box-shadow: var(--shadow-sm); z-index: 50;
      opacity:0; transition: opacity .2s ease, transform .2s ease
    }
    .toast.show{ opacity:1; transform: translateX(-50%) translateY(-4px) }

    @media (max-width: 640px){
      .container{ padding:12px; }
      .title{ font-size:18px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="container row" style="justify-content:space-between">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <div class="title">Grimoire</div>
          <div class="subtitle">Profil & Badges</div>
        </div>
      </div>
      <nav class="row" style="gap:10px">
        <a href="/index.html">‚Üê Retour</a>
        <a href="/collection.html">Collection</a>
        <a href="/profil.html" aria-current="page">Profil</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <!-- Profil joueur -->
    <section class="panel" style="grid-column:span 12; margin-bottom:16px">
      <div class="hd">
        <h3>Infos joueur</h3>
        <span id="sync" class="pill">Chargement‚Ä¶</span>
      </div>
      <div class="bd">
        <div class="statline">
          <div id="avatar" class="avatar" aria-hidden="true">üë§</div>
          <div class="user-meta">
            <div class="name" id="username">‚Äî</div>
            <div class="k">Niveau <strong id="level">0</strong> ¬∑ <span id="xpLabel">0 XP</span></div>
          </div>
        </div>
        <div class="xpwrap" style="margin-top:12px">
          <div class="xpbar" aria-label="Progression vers le prochain niveau">
            <div class="fill" id="xpFill" style="width:0%"></div>
          </div>
          <span class="pill" id="xpPct">0%</span>
        </div>
      </div>
    </section>

    <!-- Badges -->
    <section class="panel" style="grid-column:span 12">
      <div class="hd">
        <h3>Badges</h3>
        <span class="subtitle">D√©bloque-les en jouant, collectionnant et en te connectant r√©guli√®rement.</span>
      </div>
      <div class="bd">
        <div id="badges" class="badges"></div>
      </div>
    </section>
  </main>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <!-- === LOGIQUE ALIGNEE AVEC collection.html === -->
  <script type="module">
  // Firebase (modules v10, comme collection.html)
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
  import { getAuth, onAuthStateChanged, OAuthProvider, setPersistence, browserLocalPersistence } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
  import { getFirestore, doc, getDoc, setDoc, updateDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

const LS_VERSION_KEY = 'grimoire.alpha.version';
const CURRENT_LS_VERSION = 3; // incr√©mente si tu modifie l‚Äôarchitecture

const last = Number(localStorage.getItem(LS_VERSION_KEY)||0);
if (last !== CURRENT_LS_VERSION){
  // Exemple : on ne garde que la collection/stats si tu veux
  // localStorage.removeItem('grimoire.alpha.collection.v2_5');
  // localStorage.removeItem('grimoire.alpha.stats.v2_5');
  // localStorage.removeItem('grimoire.alpha.profile.v2_5');
  localStorage.setItem(LS_VERSION_KEY, String(CURRENT_LS_VERSION));
}

    
  // ---- Config identique
  const firebaseConfig = {
    apiKey: 'AIzaSyCKZK4I3li_7wkmd_qiiM44BoqRTZoloeI',
    authDomain: 'legends-collection.firebaseapp.com',
    projectId: 'legends-collection',
    storageBucket: 'legends-collection.firebasestorage.app',
    messagingSenderId: '133783086150',
    appId: '1:133783086150:web:762f209f7f778ef83a1647'
  };
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);
  try { await setPersistence(auth, browserLocalPersistence); } catch {}

  const twitchProvider = new OAuthProvider('oidc.twitch');
  try { twitchProvider.addScope('openid'); twitchProvider.addScope('user:read:email'); } catch {}

  // ---- Raret√©s + mapping (m√™me normalisation que collection.html)
  const RARITY = { COMMON:'commune', UNCOMMON:'peu commune', RARE:'rare', LEGENDARY:'l√©gendaire', EXOTIC:'exotique' };
  function mapRarity(r){
    const x=(r||'').toLowerCase();
    if(x==='common'||x==='commune') return RARITY.COMMON;
    if(x==='uncommon'||x==='peu commune') return RARITY.UNCOMMON;
    if(x==='rare') return RARITY.RARE;
    if(x==='legendary'||x==='legendaire'||x==='l√©gendaire') return RARITY.LEGENDARY;
    if(x==='exotic'||x==='exotique') return RARITY.EXOTIC;
    return RARITY.COMMON;
  }

  // ---- Chargement dynamique des sets (identique aux chemins de collection.html)
  const SET_FILES = [
    '/data/sets/nouvelle-lumiere.json',
    '/data/sets/twitch.json',
  ];

  async function loadCardSets(){
    const out = [];
    for (const url of SET_FILES){
      try{
        const res = await fetch(url, { cache:'no-store' });
        if(!res.ok) throw new Error('HTTP '+res.status);
        const data = await res.json();
        const setName =
          data?.set || data?.name ||
          (url.includes('nouvelle-lumiere') ? 'Nouvelle Lumi√®re' :
           url.includes('twitch') ? 'Twitch' : 'Set inconnu');

        if(!Array.isArray(data?.cards)) continue;
        out.push(...data.cards.map(c=>({
          id: c.id,
          name: c.name,
          set: c.set || setName,
          rarity: mapRarity(c.rarity),
          image: c.image || ''
        })));
      }catch(e){
        console.warn('[profil] loadCardSets fail', url, e);
      }
    }
    return out;
  }

  // ---- LocalStorage (m√™mes cl√©s)
  const LS_KEY='grimoire.alpha.collection.v2_5';
  const LS_STATS='grimoire.alpha.stats.v2_5';
  const LS_PROFILE='grimoire.alpha.profile.v2_5';
  function loadLS(k,def){ try{ return JSON.parse(localStorage.getItem(k))||def; }catch{ return def; } }
  function saveLS(k,v){ localStorage.setItem(k, JSON.stringify(v)); }

  // ---- Compute centralis√© (copie conforme avec le m√™me esprit que collection)
  function computeProgress({ collection, cardPools }){
    // Unique catalogue
    const allIds = new Set(cardPools.map(c=>c.id));
    const totalUnique = allIds.size;

    // Uniques poss√©d√©es (par ID, pas par quantit√©s)
    const ownedIds = Object.keys(collection).filter(id => allIds.has(id));
    const uniques = ownedIds.length;

    // % compl√©tion
    const completionPct = totalUnique ? Math.round(100 * uniques / totalUnique) : 0;

    // R√©partition par raret√© (par quantit√©s r√©elles)
    const byRarity = {
      [RARITY.COMMON]:0, [RARITY.UNCOMMON]:0, [RARITY.RARE]:0, [RARITY.LEGENDARY]:0, [RARITY.EXOTIC]:0
    };
    for(const id of ownedIds){
      const qty = collection[id] || 0;
      const card = cardPools.find(c => c.id === id);
      if(card) byRarity[card.rarity] += qty;
    }

    // Pr√©sence au moins 1 L√©gendaire/Exotique (peu importe la quantit√©)
    const legendaryOwned = ownedIds.some(id => {
      const card = cardPools.find(c=>c.id===id);
      return card && card.rarity === RARITY.LEGENDARY && (collection[id]||0) > 0;
    });
    const exoticOwned = ownedIds.some(id => {
      const card = cardPools.find(c=>c.id===id);
      return card && card.rarity === RARITY.EXOTIC && (collection[id]||0) > 0;
    });

    return { uniques, totalUnique, completionPct, byRarity, legendaryOwned, exoticOwned };
  }
    
// Version du ‚Äúsch√©ma de badges‚Äù pour forcer une resync quand la logique change
const BADGE_SCHEMA_VERSION = 2;

    // Calcule l‚Äô√©tat ‚Äúattendu‚Äù des badges √† partir des stats courantes
function computeExpectedBadges(sharedStats){
  // sharedStats = { completionPct, uniques, totalUnique, byRarity, legendaryOwned, exoticOwned, packsOpened }
  const expected = {};
  for(const b of BADGES){
    if (b.test(sharedStats)) {
      expected[b.id] = { acquiredAt: serverTimestamp() };
    }
  }
  return expected;
}

// Compare badges Cloud vs badges attendus
function diffBadges(currentBadges={}, expectedBadges={}){
  const toAdd = [];
  const toRemove = [];
  for(const id of Object.keys(currentBadges)){
    if(!(id in expectedBadges)) toRemove.push(id);
  }
  for(const id of Object.keys(expectedBadges)){
    if(!(id in currentBadges)) toAdd.push(id);
  }
  return { toAdd, toRemove };
}

    
  // ---- Badges (branch√©s sur les nouveaux champs calcul√©s)
  const BADGES = [
    // Progression (par % sur uniques/totalUnique)
    { id:'explorateur',    name:'Explorateur',         ico:'üß≠',  desc:'Avoir 10 cartes diff√©rentes',   test:s=> s.uniques >= 10 },
    { id:'collectionneur', name:'Collectionneur',      ico:'üìö',  desc:'50% de la collection',         test:s=> s.completionPct >= 50 },
    { id:'archiviste',     name:'Archiviste',          ico:'üèõÔ∏è',  desc:'100% de la collection',        test:s=> s.completionPct >= 100 },

    // Packs (stats cloud si dispo, sinon 0)
    { id:'curieux',        name:'Curieux',             ico:'üì¶',  desc:'Ouvrir un premier pack',       test:s=> (s.packsOpened||0) >= 1 },
    { id:'addict',         name:'Addict',              ico:'üì¶üì¶', desc:'Ouvrir 50 packs',              test:s=> (s.packsOpened||0) >= 50 },
    { id:'accro',          name:'Accro',               ico:'üì¶üì¶üì¶',desc:'Ouvrir 100 packs',             test:s=> (s.packsOpened||0) >= 100 },
    { id:'inarretable',    name:'Inarr√™table',         ico:'üåÄ',  desc:'Ouvrir 200 packs',             test:s=> (s.packsOpened||0) >= 200 },

    // Raret√©s (pr√©sence)
    { id:'chanceux',       name:'Chanceux',            ico:'üåü',  desc:'Trouver 1 l√©gendaire',         test:s=> !!s.legendaryOwned },
    { id:'benisdesneuf',   name:'B√©nis des Neuf',      ico:'‚ú®',  desc:'Trouver 1 exotique',           test:s=> !!s.exoticOwned },
    { id:'chasseur',       name:'Chasseur de tr√©sors', ico:'üíé',  desc:'10 l√©gendaires/exotiques',     test:s=> ((s.byRarity['l√©gendaire']||0)+(s.byRarity['exotique']||0)) >= 10 },
  ];

  // ---- UI helpers
  const $ = (sel)=> document.querySelector(sel);
  const toastEl = $('#toast');
  function toast(msg, ms=1800){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    setTimeout(()=> toastEl.classList.remove('show'), ms);
  }
  function renderBadges(container, defs, ownedMap){
    container.innerHTML = '';
    defs.forEach(b=>{
      const unlocked = !!ownedMap[b.id];
      const date = ownedMap[b.id]?.acquiredAt ? new Date(ownedMap[b.id].acquiredAt.seconds*1000) : null;

      const card = document.createElement('div');
      card.className = 'badge-card'+(unlocked?'':' locked');
      card.innerHTML = `
        <div class="badge-state">${unlocked? 'D√©bloqu√©' : 'Verrouill√©'}</div>
        <div class="badge-ico" aria-hidden="true">${b.ico}</div>
        <div class="badge-name">${b.name}</div>
        <div class="badge-desc">${b.desc}</div>
        ${unlocked && date ? `<div class="date">D√©bloqu√© le ${date.toLocaleDateString()}</div>` : ''}
      `;
      container.appendChild(card);
    });
  }

  // ---- Refs DOM
  const usernameEl = $('#username');
  const levelEl    = $('#level');
  const xpLabelEl  = $('#xpLabel');
  const xpFillEl   = $('#xpFill');
  const xpPctEl    = $('#xpPct');
  const avatarEl   = $('#avatar');
  const syncBadge  = $('#sync');
  const badgesWrap = $('#badges');

  // ---- Etat
  let cardPools = [];
  let collection = loadLS(LS_KEY, {});
  let stats = loadLS(LS_STATS, { packsOpened: 0 });
  let profileLS = loadLS(LS_PROFILE, { level:1, xp:0 });

  // ---- Orchestration
  // 1) Charger le catalogue
  cardPools = await loadCardSets();

  // 2) Auth & synchro Cloud ‚Üí Local, puis calcul des stats communes
  onAuthStateChanged(auth, async (user)=>{
    if(!user){
      syncBadge.textContent = 'Hors ligne';
      usernameEl.textContent = 'Invit√©';
      levelEl.textContent = String(profileLS.level||0);
      xpLabelEl.textContent = `${profileLS.xp||0} XP`;
      const p = Math.max(0, Math.min(100, Math.round((profileLS.xp / Math.max(1,100)) * 100)));
      xpFillEl.style.width = p + '%';
      xpPctEl.textContent = p + '%';

      const progress = computeProgress({ collection, cardPools });
      draw(progress, {});
      return;
    }

    syncBadge.textContent = 'Sync‚Ä¶';
    avatarEl.textContent = 'üë§';

    const ref = doc(db,'players',user.uid);
    const snap = await getDoc(ref);
    const data = snap.exists()? snap.data() : {};

    // R√©cup collection (divers sch√©mas)
    function collectOwned(d){
      const ids = {};
      if (d.collection && typeof d.collection === 'object'){
        for (const [id, qty] of Object.entries(d.collection)) ids[id]=Number(qty||0);
      }
      if (d.collections && typeof d.collections === 'object'){
        for (const setObj of Object.values(d.collections)){
          if (setObj && typeof setObj === 'object'){
            for (const [id, qty] of Object.entries(setObj)) ids[id]=(ids[id]||0)+Number(qty||0);
          }
        }
      }
      if (Array.isArray(d.cardsOwned)){
        for (const entry of d.cardsOwned){
          if (typeof entry === 'string') ids[entry]=(ids[entry]||0)+1;
          else if (entry && entry.id) ids[entry.id]=(ids[entry.id]||0)+Number(entry.qty||1);
        }
      }
      return ids;
    }

    collection = collectOwned(data);
    stats.packsOpened = data.packsOpened ?? data.stats?.packsOpened ?? stats.packsOpened ?? 0;
    profileLS.level = data.level ?? profileLS.level ?? 1;
    profileLS.xp    = data.xp    ?? profileLS.xp    ?? 0;

    saveLS(LS_KEY, collection); saveLS(LS_STATS, stats); saveLS(LS_PROFILE, profileLS);

    // UI Infos joueur
    usernameEl.textContent = data.pseudo || user.displayName || user.email || 'Joueur';
    levelEl.textContent = String(profileLS.level||0);
    xpLabelEl.textContent = `${profileLS.xp||0} XP`;
    const p = Math.max(0, Math.min(100, Math.round((profileLS.xp / Math.max(1, data.xpToLevel||100)) * 100)));
    xpFillEl.style.width = p + '%';
    xpPctEl.textContent = p + '%';

    const progress = computeProgress({ collection, cardPools });

    // Fusion des stats utiles pour badges
    const sharedStats = {
      ...progress,
      packsOpened: stats.packsOpened
    };

    // Badges existants
    let ownedBadges = data.badges || {};

   // 1) Calculs partag√©s (tu as d√©j√† progress = computeProgress({ collection, cardPools }))
const sharedStats = {
  ...progress,
  packsOpened: stats.packsOpened // si tu as une source packsOpened c√¥t√© cloud, garde-la ici
};

// 2) Badges actuels en base
let ownedBadges = data.badges || {};

// 3) Badges attendus selon la logique courante
const expected = computeExpectedBadges(sharedStats);

// 4) Diff (ajouts/suppressions)
const { toAdd, toRemove } = diffBadges(ownedBadges, expected);

// 5) Faut-il √©crire (ajout/suppression/version) ?
const needsVersionBump = (data.badgeSchemaVersion || 0) !== BADGE_SCHEMA_VERSION;

if (toAdd.length || toRemove.length || needsVersionBump) {
  const now = serverTimestamp();
  const finalBadges = { ...ownedBadges };

  // retirer les badges obsol√®tes
  for(const id of toRemove){ delete finalBadges[id]; }
  // ajouter ceux manquants
  for(const id of toAdd){ finalBadges[id] = { acquiredAt: now }; }

  try{
    await updateDoc(ref, {
      badges: finalBadges,
      badgeSchemaVersion: BADGE_SCHEMA_VERSION,
      updatedAt: now
    });

    if (toAdd.length || toRemove.length) {
      const plus = toAdd.length ? `+${toAdd.length}` : '';
      const moins = toRemove.length ? `-${toRemove.length}` : '';
      toast(`Badges resynchronis√©s ${[plus,moins].filter(Boolean).join(' / ')}`);
    }

    // relire pour l‚Äôaffichage
    const snap2 = await getDoc(ref);
    ownedBadges = (snap2.exists()? snap2.data().badges : finalBadges) || finalBadges;

  }catch(e){
    console.error(e);
    toast('Erreur lors de la resynchronisation des badges');
  }
}

// 6) Rendu UI (toujours √† la fin)
renderBadges(badgesWrap, BADGES, ownedBadges || {});
syncBadge.textContent = 'En ligne';


  function draw(sharedStats, ownedBadges){
    renderBadges(badgesWrap, BADGES, ownedBadges || {});
    // (Optionnel) log debug :
    // console.log('[profil] stats partag√©es', sharedStats);
  }
  </script>
</body>
</html>
